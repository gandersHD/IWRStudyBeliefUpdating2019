#functions for working with datasets

#name list of specific name for each part of a list (with possible enumeration)
f_nameﬂlist <- function(list_data,names_data,name_topic="",b_enumerate=FALSE,N_enumb=length(names_data)){
  "Returns a list with named elements either by using a string of names or enumerating in the form name_topic.N
  (default is using string of names)
  
  Keyword arguments:
  list_data -- the list to be named (list)
  names_data -- names for each element of the list (vector of strings)
  name_topic -- name for each element of the list if enumeration is used (string)
  b_enumerate -- choose if names are generated by enumeration (boolian)
  N_enumb -- number of elements to name (numeric)
  "
  
  list_result = list_data
  
  if(b_enumerate == TRUE){
    names_listelem = c()
    for (j in 1:N_enumb) {
      names_listelem[j] = paste0(name_topic,j)
    }
    names(list_result) = names_listelem
  }
  
  else{
    names(list_result) = names_data
  }
  
  return(list_result)
}

#return a list of datasets from a exeltable corresponding to different choosen topics (used for initial cut of the dataframe)
f_readﬂdataset <- function(name_directory,name_filename,list_topics,names_topics = names(list_topics)){
  "Returns a (named) list of tables cut for a list of topics that give the ranges for each topic
  from a exelfile storing the completa data
  
  Keyword arguments:
  name_directory -- gives the directory in which the data is stored (string)
  name_filename -- gives the name of file including the .xls or .xlsx (string)
  list_topics -- list of vectors that contain the points where the datasets should be seperated (list of vectors)
  names_topics -- the listelements can be named using a vector of names (string of vectors)
  "
  
  list_dataset <- list()
  
  #ins Verzeichnis gehen und Daten einlesen
  setwd(name_directory)
  data_set <- read_excel(name_filename)
  
  for (i in 1:length(list_topics)) {
    Lelem <- data_set[, list_topics[[i]]]
    list_dataset[[length(list_dataset)+1]] = Lelem
  }
  
  list_dataset <- f_nameﬂlist(list_dataset,names_topics)
  
  return(list_dataset)
}

#create a list of datamatrices named after some specifics and modify the entrys by numbers (results in matrices have to be numeric!)
f_createﬂlisttopic <- function(table_data,list_topic,vector_topicﬂmodifiers){
  "Returns a table that has (n=length(list_topic)) datamatrices cut fram a given table into topics as entries
  
  Keyword arguments:
  table_data -- gives the datatable from which the datamatrices are created (table)
  list_topic -- gives a list of vectors that name the tablerows to be used for the specific topic (list of vectors)
  vector_topicﬂmodifiers -- a vector of length = length(list_topic) that gives the numerics that are substracted from each datamatrix (vector)
  "
  
  list_result <- list()
  
  for (i in 1:length(list_topic)) {
    Lelem <- f_modifyﬂtable(table_data,list_topic[[i]],vector_topicﬂmodifiers[i])
    list_result[[length(list_result)+1]] = Lelem
  }
  
  list_result <- f_nameﬂlist(list_result,names(list_topic))
  
  return(list_result)
}

#create a subtable from a table and modify its values
f_modifyﬂtable <- function(table_data,vector_cut,N_modifier = NULL){
  "Returns a table that is a subtable cut of a larger table where a modifier is substracted from each tablevalue
  
  Keyword arguments:
  table_data -- gives the datatable the rows are selected from (table)
  vector_cut -- the vector that gives the rows that are used in the modified table (vector)
  N_modifier -- Number that is substracted from each entry of the table (numeric)
  "
  
  table_result <- table_data[,vector_cut]
  matrix_result <- data.matrix(table_result, rownames.force = NA)
  matrix_result = matrix_result - N_modifier
  
  return(matrix_result)
}

#binding data for datasets rowwise
f_bindingﬂdata <- function(list_data,vector_bindinfo,name_listtopic="",names_newlistelem=c()){
  "Returns a list that binds rows of an inut list together dependent on the info in the vector_bindinfo
  and can named using enumeration or given specific names
  
  Keyword arguments:
  list_data -- the list for which list enteries should be bount together by adding the second one on the rowwise ends of the first one
  vector_bindinfo -- the vector that gives infos which rows to bind together each vector entry consissts of a string of n numbers seperated by ','.
                    The number of vectorelemnts gives the number of resulting listenelements each eantry gives the numbers of the lists to bind together 
  name_listtopic -- name used if the listeelemnts are enumerated (string)
  names_newlistelem -- vector of names for each of the new listelemnts (has to be of same lenght as vector_bindinfo)
  "
  
  list_merge <- list()
  
  #find which listelements should be bound togehter
  boundelemi = list()
  
  for (i in 1:length(vector_bindinfo)){
    boundelemi[[i]] = scan(textConnection(vector_bindinfo[i]),sep = ",")
  }
  
  for (i in 1:length(vector_bindinfo)){
    
    Lelem <- data.frame()
    
    for(j in boundelemi[[i]]){
      
      temp <- list_data[[j]]
      
      if(j == 1){
        Lelem <- temp
      }
      
      else{
        Lelem <- rbind(Lelem, temp)
      }
    }
    list_merge[[length(list_merge)+1]] = Lelem
  }
  
  if(length(names_newlistelem) == 0){
    list_merge <- f_nameﬂlist(list_merge,"",name_listtopic,TRUE,length(vector_bindinfo))
  }
  
  else{
    list_merge <- f_nameﬂlist(list_merge,names_newlistelem)
  }
  
  return(list_merge)
}

#creates a list of subsets with a specific conditon from the sets
f_data_conditioner <- function(data_input,N_Cond,name_cond,b_continous=TRUE,data_Cond,condition){
  "Returns a list of dataframes by spliiting a df using aspecific condition that is checked against another dataframe
  
  there are four types of conditions that can be applied:
  1.  interval scale: give a vector of the following form: c('part1ofcond1,part2ofcond1','part1ofcond2')
  where the parts are the values corresponding to the condition
  2.  ordinal scale or above split in equal distance: condition is the numeric that is used to split the data
  the median is used to split into high/lowscorers (median to create sample sets similar in size)
  3.  ordinal scale or above split in custom intervalls: condition is a vector that gives the breakpoints
  (above 0 -> dont specify lower bound interval)
  
  Keyword arguments:
  data_input -- name of dataframename to be split (dataframe or matrix)
  N_Cond -- Number of different conditions (numeric)
  name_cond -- name of the condition: used to name listelements (String)
  b_continous -- if the condition is of ordinal scale or above (boolian)
  data_Cond -- name of dataframe containing the condition: must be equal size to data (dataframe or matrix)
  condition -- selectioncondition for expleation see above
  "
  
  list_cond <- list()
  
  #Splittion into N.Cond datasets with data at leasts of ordinal scale and condition of equal distance
  #(will be used if data is split in halfs)
  if(b_continous == TRUE & is.numeric(condition) == TRUE){
    conditioni = 0
    conditioni1 = condition
    
    for (i in 1:N_Cond) {
      Lelem <- data_input[which(conditioni <= data_Cond & data_Cond <= conditioni1),]
      list_cond[[length(list_cond)+1]] = Lelem
      
      conditioni = conditioni1
      conditioni1 = conditioni + condition
      
    }
    
    list_cond <-f_nameﬂlist(list_cond,"",name_topic = name_cond,b_enumerate = TRUE,N_enumb = N_Cond)
    
    return(list_cond)
  }
  
  #Splitting into N.cond datasets with data at least of ordinal scale with condition givin specific points
  
  else if(b_continous == TRUE & is.vector(condition) == TRUE){
    
    #look if conditions have correct length
    if(length(condition) != N_Cond){
      return(warning('the condition vector does not match the number of conditions'))
    }
    
    else{
      
      conditioni = c(0, condition)
      
      for (i in 1:length(condition)) {
        Lelem <- data_input[which(conditioni[i] <= data_Cond & data_Cond < conditioni[i+1]),]
        list_cond[[length(list_cond)+1]] = Lelem
      }
      
      list_cond <- f_nameﬂlist(list_cond,"",name_topic = name_cond,b_enumerate = TRUE,N_enumb = N_Cond)
      
      return(list_cond)
    }
  }
  
  #if condition is of nominal scale
  else if (b_continous == FALSE){
    "the conditions are reported in the following structure:
    c('part1ofcond1,part2ofcond1','part1ofcond2')
    "
    
    #condition is disected result is the textvector
    conditioni = list()
    conditiontext = c()
    text = c()
    
    for (i in 1:N_Cond) {
      N_subc = c()
      conditioni[[i]] = scan(textConnection(condition[i]), sep=",")
      N_subc[i] = length(conditioni[[i]])
      
      
      
      for(j in 1:N_subc[i]){
        temp = paste0("data_Cond == ", conditioni[[i]][j])
        
        if(j == 1){
          text[i] = temp
        }
        
        else{
          text[i] = paste(text[i],"|",temp)
        }
      }
    }
    
    #create the datasets
    for (i in 1:N_Cond){
      Lelem <- data_input[which(eval(parse(text = text[i]))),]
      list_cond[[length(list_cond)+1]] = Lelem
    }
    
    list_cond <- f_nameﬂlist(list_cond,"",name_topic = name_cond,b_enumerate = TRUE,N_enumb = N_Cond)
    
    return(list_cond)
  }
  
  else{
    return(warning('the selected condition and data does not match'))
  }
}


